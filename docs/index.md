**SUBGRAPHS**

*Why* should we use subgraphs?
*When* do we use subgraphs?
*How* do we use subgraphs?
*Where* do we use subgraphs?


**WHY?**

- Quick Access to historical blockchain data with almost *no delay*
- Subgraphs are very *simple*
- They serve as an off-chain *data storage* with Graph QL API and virtually *no limits* 
- Simple *data processing* and *manipulation*
- *Quick* and *easy*

**WHEN?**

There are some specific cases for which subgraphs are not preferrable, however, the following are the cases for which they are useful:

- If the chain is supported (there are still some chains that don’t support it)
- When working with historical data on a regular basis. It’s especially useful when dealing with large volumes of historical data and periodic updates with new blocks.
- If it’s OK to wait a short time when listing new blocks, as it takes a short time before subgraphs catch up
- When you’re not working and/or aggregating data from numerous different data sources, because, even though it can handle data from many different sources and there are various workarounds, it’s still not possible to have one deployment on multiple chains. There’s an automatic solution that can do that for you, but if it’s only one occasion involving many different chains - some of which are not supported - then subgraphs might not be the best approach. 

**HOW?**

You can use a template for deployment, run some script, configure it, and it will deploy automatically, or you can start from scratch, if you prefer.
Check the prerequisites for anything you need to install.
Create a subgraph in The Graph.com

**TASK**

Using the Contract Address, Processed events, you can easily create a subgraph or API using the User Address and Token Address as input and it gives you an accumulated mosaic from those events.
Add Title, Subtitle, and there’s an option to hide it from Explorer while keeping it accessible if you have the address
Then, click Create (it may take a short time to be created)

Once you save it, it will be put into easy-to-read formatting. This is the end of the first step.

Having adjusted the contract manually, you have everything you need, at this point you can remove most of the code as you won’t need it, but it’s OK to leave it.

**Graph base commands:**

graph codegen
graph build
graph create <subgraph-name>
graph deploy <subgraph-name>


**Package json**
  
Contains all the script you will be using 

This is used when other users want to deploy to the same space. That user needs to authenticate. The first time you will receive information about how to deploy and receive the access key.
  
Use Alt function with the specific key, so people from different accounts can contribute to the same deployment.

**Subgraph Yaml**

This should have all the information you need for defining what you are looking for, but you can make some adjustments here, such as entities, address, etc.

You don’t need to go to the whole chain, you just stick with the one block and from that one, make sure that there are no blocks skipped - as an extra security measure.
  
Then you have generated exactly what it should be looking for in the blockchain and then all the information about how it should generate all the classes in the background which will then be able to work with and all the handlers

You will see from these steps how much information is autogenerated and how much quicker it is compared to doing this manually
Due to the autogeneration, based on json and schema, etc., multiple scripts and classes can be generated in the background, so you need to run Codegen to make changes to the files.

**Graph QL API**
You should think of this as an Interface for the data retrieval

**LAST STEP:**

**MAPPING**

Mappings perform transformation data from blockchain (event) data entity.

Write mapping in a subset of TypeScript called AssemblyScript, which can be compiled down to WASM. For every event handler, you should create an export function. That function only has one argument, which is an event object.
  
Base entity functions: save, load, remove
  
Get data from the contract: any state variable that is marked public or any view function that can be accessed.

Create a new user ID, with data associated with that specific ID, and then populate all the fields.

**WHERE?**

No need for online repository. You can deploy it automatically with the following setup:
(link)

You can find an example of the live playground here:
https://thegraph.com/hosted-service/subgraph/hehe100596/template-subgraph
You can find more info in the docs or a previous working (TheGraph.pdf)
